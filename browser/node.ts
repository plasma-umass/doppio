// Generated by CoffeeScript 1.6.2
(function() {
  "use strict";
  var CacheSource, CompositedFileSource, DoppioFile, FSState, FileIndex, FileSource, GetIEByteArray_ByteStr, LocalStorageSource, Stat, WebserverSource, basename, canUsePostMessage, fs_state, handleMessage, inject_vbscript, messageName, root, setZeroTimeout, timeouts, win, _,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
    __slice = [].slice;

  win = window;

  root = win.node = {};

  basename = function(path) {
    return path.split('/').pop();
  };

  win.require = function(path, herp) {
    var ext, name, _ref, _ref1;

    if (herp != null) {
      path = herp;
    }
    _ref = basename(path).split('.'), name = _ref[0], ext = _ref[1];
    return (_ref1 = window[name]) != null ? _ref1 : window[name] = {};
  };

  _ = require('../vendor/_.js');

  inject_vbscript = function() {
    var IEBinaryToArray_ByteStr_Script;

    IEBinaryToArray_ByteStr_Script = "<!-- IEBinaryToArray_ByteStr -->\r\n" + "<script type='text/vbscript'>\r\n" + "Function IEBinaryToArray_ByteStr(Binary)\r\n" + "   IEBinaryToArray_ByteStr = CStr(Binary)\r\n" + "End Function\r\n" + "Function IEBinaryToArray_ByteStr_Last(Binary)\r\n" + "   Dim lastIndex\r\n" + "   lastIndex = LenB(Binary)\r\n" + "   if lastIndex mod 2 Then\r\n" + "       IEBinaryToArray_ByteStr_Last = Chr( AscB( MidB( Binary, lastIndex, 1 ) ) )\r\n" + "   Else\r\n" + "       IEBinaryToArray_ByteStr_Last = " + '""' + "\r\n" + "   End If\r\n" + "End Function\r\n" + "</script>\r\n";
    return document.write(IEBinaryToArray_ByteStr_Script);
  };

  if ($.browser.msie && !window.Blob) {
    inject_vbscript();
  }

  GetIEByteArray_ByteStr = function(IEByteArray) {
    var lastChr, rawBytes;

    rawBytes = IEBinaryToArray_ByteStr(IEByteArray);
    lastChr = IEBinaryToArray_ByteStr_Last(IEByteArray);
    return rawBytes.replace(/[\s\S]/g, (function(match) {
      var v;

      v = match.charCodeAt(0);
      return String.fromCharCode(v & 0xff, v >> 8);
    })) + lastChr;
  };

  timeouts = [];

  messageName = "zero-timeout-message";

  canUsePostMessage = function() {
    var oldOnMessage, postMessageIsAsync;

    if (!window.postMessage) {
      return false;
    }
    postMessageIsAsync = true;
    oldOnMessage = window.onmessage;
    window.onmessage = function() {
      return postMessageIsAsync = false;
    };
    window.postMessage('', '*');
    window.onmessage = oldOnMessage;
    return postMessageIsAsync;
  };

  if (canUsePostMessage()) {
    setZeroTimeout = function(fn) {
      timeouts.push(fn);
      return window.postMessage(messageName, "*");
    };
    handleMessage = function(event) {
      var fn;

      if (event.source === self && event.data === messageName) {
        if (event.stopPropagation) {
          event.stopPropagation();
        } else {
          event.cancelBubble = true;
        }
        if (timeouts.length > 0) {
          fn = timeouts.shift();
          return fn();
        }
      }
    };
    if (window.addEventListener) {
      window.addEventListener('message', handleMessage, true);
    } else {
      window.attachEvent('onmessage', handleMessage);
    }
  } else {
    setZeroTimeout = function(fn) {
      var scriptEl;

      return setTimeout(fn, 0);
      scriptEl = window.document.createElement("script");
      scriptEl.onreadystatechange = function() {
        fn();
        scriptEl.onreadystatechange = null;
        scriptEl.parentNode.removeChild(scriptEl);
        return scriptEl = null;
      };
      window.document.documentElement.appendChild(scriptEl);
    };
  }

  DoppioFile = (function() {
    DoppioFile.fromJSON = function(path, rawData) {
      var data;

      data = JSON.parse(rawData);
      return new DoppioFile(path, data.data, data.mtime, false, data.mode);
    };

    function DoppioFile(path, data, mtime, mod, mode) {
      this.path = path;
      this.data = data != null ? data : "";
      this.mtime = mtime != null ? mtime : (new Date).getTime();
      this.mod = mod != null ? mod : false;
      this.mode = mode != null ? mode : 0x1a4;
    }

    DoppioFile.prototype.read = function(length, pos) {
      if (length == null) {
        return this.data;
      }
      return this.data.substr(pos, length);
    };

    DoppioFile.prototype.write = function(newData, pos) {
      this.mod = true;
      if ((pos != null) && pos < this.data.length) {
        this.data = this.data.slice(0, pos) + newData + this.data.slice(pos + newData.length);
      } else {
        this.data += newData;
      }
      return this;
    };

    DoppioFile.prototype.toJSON = function() {
      return JSON.stringify({
        data: this.data,
        mtime: this.mtime,
        mode: this.mode
      });
    };

    return DoppioFile;

  })();

  FileIndex = (function() {
    function FileIndex(index) {
      this.index = index != null ? index : {};
    }

    FileIndex.prototype._subcomponents = function(path) {
      var components;

      components = path.split('/');
      components.shift();
      if (components.length === 1 && components[0] === '') {
        return [];
      } else {
        return components;
      }
    };

    FileIndex.prototype._add_file = function(components, fname, file) {
      var dir;

      dir = this._mkdir(components);
      dir[fname] = file;
    };

    FileIndex.prototype._mkdir = function(components) {
      var c, cur_dir, _i, _len, _ref;

      cur_dir = this.index;
      for (_i = 0, _len = components.length; _i < _len; _i++) {
        c = components[_i];
        if ((_ref = cur_dir[c]) == null) {
          cur_dir[c] = {};
        }
        cur_dir = cur_dir[c];
      }
      return cur_dir;
    };

    FileIndex.prototype._get = function(components) {
      var c, cur_dir, _i, _len;

      cur_dir = this.index;
      for (_i = 0, _len = components.length; _i < _len; _i++) {
        c = components[_i];
        if (!(c in cur_dir)) {
          return false;
        }
        cur_dir = cur_dir[c];
      }
      return cur_dir;
    };

    FileIndex.prototype._is_directory = function(obj) {
      return (obj != null) && !(obj instanceof DoppioFile);
    };

    FileIndex.prototype.add_file = function(path, file) {
      var components, fname;

      components = this._subcomponents(path);
      fname = components.pop();
      this._add_file(components, fname, file);
    };

    FileIndex.prototype.get_file = function(path) {
      var components, f;

      components = this._subcomponents(path);
      f = this._get(components);
      if (!(f === false || this._is_directory(f))) {
        return f;
      }
      return false;
    };

    FileIndex.prototype.ls = function(path) {
      var components, dir;

      components = this._subcomponents(path);
      dir = this._get(components);
      if (!(dir === false || !this._is_directory(dir))) {
        return Object.keys(dir);
      }
      return null;
    };

    FileIndex.prototype.mkdir = function(path) {
      var components;

      components = this._subcomponents(path);
      this._mkdir(components);
    };

    FileIndex.prototype.parent = function(path) {
      var components;

      components = this._subcomponents(path);
      components.pop();
      return this._get(components);
    };

    FileIndex.prototype.rm = function(path) {
      var components, name, obj, parent, ret;

      components = this._subcomponents(path);
      name = components.pop();
      parent = this._get(components);
      ret = false;
      if ((parent != null) && parent !== false) {
        if (name in parent) {
          obj = parent[name];
          ret = this._is_directory(obj) ? Object.keys(obj) : true;
          delete parent[name];
        }
      }
      return ret;
    };

    return FileIndex;

  })();

  FileSource = (function() {
    FileSource.prototype.redundant_storage = false;

    FileSource.prototype._trim_mnt_pt = function(path) {
      return path.slice(this.mnt_pt.length);
    };

    function FileSource(mnt_pt) {
      this.mnt_pt = mnt_pt;
    }

    FileSource.prototype.fetch = function(path) {
      return null;
    };

    FileSource.prototype.store = function(path, file) {
      return false;
    };

    FileSource.prototype.rm = function(path) {
      return false;
    };

    FileSource.prototype.ls = function(path) {
      return null;
    };

    FileSource.prototype.mv = function(path1, path2, isFile) {
      if (isFile == null) {
        isFile = true;
      }
      return false;
    };

    FileSource.prototype.mkdir = function(path1) {
      return false;
    };

    return FileSource;

  })();

  CompositedFileSource = (function(_super) {
    __extends(CompositedFileSource, _super);

    CompositedFileSource.prototype._in_mnt_pt = function(path, mnt_pt) {
      return mnt_pt === '/' || path === mnt_pt || (path.slice(0, mnt_pt.length) === mnt_pt && path[mnt_pt.length] === '/');
    };

    CompositedFileSource.prototype._get_applicable_sources = function(path) {
      var a_mnt_pt, applicable, _i, _len, _ref;

      applicable = [];
      _ref = this.mnt_pts;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        a_mnt_pt = _ref[_i];
        if (this._in_mnt_pt(path, a_mnt_pt)) {
          applicable.push(this.sources[a_mnt_pt]);
        }
      }
      return applicable;
    };

    function CompositedFileSource(mnt_pt, inpt_sources) {
      var source, _i, _len;

      if (inpt_sources == null) {
        inpt_sources = [];
      }
      CompositedFileSource.__super__.constructor.call(this, mnt_pt);
      this.sources = {};
      this.mnt_pts = [];
      this.redundant_storage = false;
      for (_i = 0, _len = inpt_sources.length; _i < _len; _i++) {
        source = inpt_sources[_i];
        this.add_source(source);
      }
    }

    CompositedFileSource.prototype.add_source = function(source) {
      this.sources[source.mnt_pt] = source;
      this.mnt_pts.push(source.mnt_pt);
      this.redundant_storage || (this.redundant_storage = source.redundant_storage);
    };

    CompositedFileSource.prototype.fetch = function(path) {
      var applicable, f, parent, _i, _len;

      applicable = this._get_applicable_sources(path);
      for (_i = 0, _len = applicable.length; _i < _len; _i++) {
        parent = applicable[_i];
        f = parent.fetch(path);
        if (f != null) {
          return f;
        }
      }
      return null;
    };

    CompositedFileSource.prototype.store = function(path, file) {
      var applicable, source, stored, _i, _len;

      applicable = this._get_applicable_sources(path);
      stored = false;
      for (_i = 0, _len = applicable.length; _i < _len; _i++) {
        source = applicable[_i];
        if (!(stored && !source.redundant_storage)) {
          stored = source.store(path, file) || stored;
        }
      }
      return stored;
    };

    CompositedFileSource.prototype.rm = function(path) {
      var applicable, removed, source, _i, _len;

      applicable = this._get_applicable_sources(path);
      removed = false;
      for (_i = 0, _len = applicable.length; _i < _len; _i++) {
        source = applicable[_i];
        if (!(removed && !source.redundant_storage)) {
          removed = source.rm(path) || removed;
        }
      }
      return removed;
    };

    CompositedFileSource.prototype.ls = function(path) {
      var applicable, list, source, src_list, _i, _len;

      applicable = this._get_applicable_sources(path);
      list = null;
      for (_i = 0, _len = applicable.length; _i < _len; _i++) {
        source = applicable[_i];
        src_list = source.ls(path);
        if (src_list != null) {
          list = list != null ? _.union(list, src_list) : src_list;
        }
      }
      return list;
    };

    CompositedFileSource.prototype.mv = function(path1, path2, isFile) {
      var applicable, moved, source, _i, _len;

      if (isFile == null) {
        isFile = true;
      }
      applicable = this._get_applicable_sources(path1);
      moved = false;
      for (_i = 0, _len = applicable.length; _i < _len; _i++) {
        source = applicable[_i];
        moved = source.mv(path1, path2, isFile) || moved;
      }
      return moved;
    };

    CompositedFileSource.prototype.mkdir = function(path) {
      var applicable, dirmade, source, _i, _len;

      applicable = this._get_applicable_sources(path);
      dirmade = false;
      for (_i = 0, _len = applicable.length; _i < _len; _i++) {
        source = applicable[_i];
        dirmade || (dirmade = source.mkdir(path));
      }
      return dirmade;
    };

    return CompositedFileSource;

  })(FileSource);

  LocalStorageSource = (function(_super) {
    __extends(LocalStorageSource, _super);

    LocalStorageSource.prototype.redundant_storage = true;

    function LocalStorageSource(mnt_pt) {
      var i, _i, _ref;

      LocalStorageSource.__super__.constructor.call(this, mnt_pt);
      this.index = new FileIndex();
      for (i = _i = 0, _ref = localStorage.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
        this.index.add_file(localStorage.key(i), null);
      }
    }

    LocalStorageSource.prototype.fetch = function(path) {
      var data;

      data = localStorage.getItem(path);
      if (data != null) {
        return DoppioFile.fromJSON(path, data);
      } else {
        return null;
      }
    };

    LocalStorageSource.prototype.store = function(path, file) {
      var e;

      try {
        if (file.mod && !file.temp) {
          localStorage.setItem(path, file.toJSON());
        }
        this.index.add_file(path, file);
        return true;
      } catch (_error) {
        e = _error;
        return false;
      }
    };

    LocalStorageSource.prototype.rm = function(path) {
      var itPath, item, listing, _i, _len;

      listing = this.index.rm(path);
      if (typeof listing !== 'boolean') {
        for (_i = 0, _len = listing.length; _i < _len; _i++) {
          item = listing[_i];
          itPath = path + '/' + item;
          localStorage.removeItem(itPath);
        }
      } else if (localStorage.getItem(path) != null) {
        localStorage.removeItem(path);
      } else {
        return false;
      }
      return true;
    };

    LocalStorageSource.prototype.ls = function(path) {
      return this.index.ls(path);
    };

    LocalStorageSource.prototype.mv = function(path1, path2, isFile) {
      var f_name, file1_ls, file1_obj, _i, _len;

      if (isFile == null) {
        isFile = true;
      }
      if (isFile) {
        file1_obj = this.fetch(path1);
        if (!((file1_obj != null) && this.rm(path1))) {
          return false;
        }
        file1_obj.path = path2;
        file1_obj.mod = true;
        this.store(path2, file1_obj);
      } else {
        file1_ls = this.index.ls(path1);
        if (file1_ls == null) {
          return false;
        }
        this.index.mkdir(path2);
        for (_i = 0, _len = file1_ls.length; _i < _len; _i++) {
          f_name = file1_ls[_i];
          this.mv(f_name, path2 + f_name.substr(path1.length), true);
        }
        this.index.rm(path1);
      }
      return true;
    };

    LocalStorageSource.prototype.mkdir = function(path) {
      if (!this.index.parent(path)) {
        return false;
      }
      this.index.mkdir(path);
      return true;
    };

    return LocalStorageSource;

  })(FileSource);

  WebserverSource = (function(_super) {
    __extends(WebserverSource, _super);

    WebserverSource.prototype._download_file = function(path) {
      var array, char, data, i, req, typed_array, _i, _len;

      if ((this.index != null) && this.index.get_file(this.mnt_pt + path) === false) {
        return null;
      }
      data = null;
      if (!$.browser.msie) {
        $.ajax(path, {
          type: 'GET',
          dataType: 'text',
          async: false,
          beforeSend: function(jqXHR) {
            return jqXHR.overrideMimeType('text/plain; charset=x-user-defined');
          },
          success: function(theData, status, jqxhr) {
            return data = theData;
          }
        });
      } else if (window.Blob) {
        req = new XMLHttpRequest();
        req.open('GET', path, false);
        req.responseType = 'arraybuffer';
        req.send();
        if (req.status === 200) {
          typed_array = new Uint8Array(req.response);
          array = [];
          for (i = _i = 0, _len = typed_array.length; _i < _len; i = ++_i) {
            char = typed_array[i];
            array[i] = String.fromCharCode(char);
          }
          data = array.join("");
        }
      } else {
        req = new XMLHttpRequest();
        req.open('GET', path, false);
        req.setRequestHeader("Accept-Charset", "x-user-defined");
        req.send();
        if (req.status === 200) {
          data = GetIEByteArray_ByteStr(req.responseBody);
        }
      }
      return data;
    };

    function WebserverSource(mnt_pt, listings_path) {
      var idx_data;

      WebserverSource.__super__.constructor.call(this, mnt_pt);
      if (listings_path != null) {
        idx_data = this._download_file(listings_path);
      }
      this.index = new FileIndex(idx_data != null ? JSON.parse(idx_data) : void 0);
    }

    WebserverSource.prototype.fetch = function(path) {
      var data, f, trim_path;

      f = this.index.get_file(path);
      if (f === false) {
        return null;
      }
      trim_path = this._trim_mnt_pt(path);
      data = this._download_file(trim_path);
      if (data != null) {
        return new DoppioFile(path, data);
      } else {
        return null;
      }
    };

    WebserverSource.prototype.ls = function(path) {
      return this.index.ls(path);
    };

    WebserverSource.prototype.rm = function(path) {
      return this.index.rm(path);
    };

    return WebserverSource;

  })(FileSource);

  CacheSource = (function(_super) {
    __extends(CacheSource, _super);

    function CacheSource(mnt_pt, src) {
      CacheSource.__super__.constructor.call(this, mnt_pt);
      this.src = src;
      this.redundant_storage = src.redundant_storage;
      this.index = new FileIndex();
    }

    CacheSource.prototype.fetch = function(path) {
      var f;

      f = this.index.get_file(path);
      if (f === false) {
        f = this.src.fetch(path);
        if (f != null) {
          this.index.add_file(path, f);
        }
      }
      return f;
    };

    CacheSource.prototype.store = function(path, file) {
      if (this.src.store(path, file)) {
        this.index.add_file(path, file);
        return true;
      }
      return false;
    };

    CacheSource.prototype.rm = function(path) {
      if (this.src.rm(path)) {
        this.index.rm(path);
        return true;
      }
      return false;
    };

    CacheSource.prototype.ls = function(path) {
      return this.src.ls(path);
    };

    CacheSource.prototype.mkdir = function(path) {
      return this.src.mkdir(path);
    };

    CacheSource.prototype.mv = function(file1, file2, isFile, ignoreSrc) {
      var f, f_name, ls, success, _i, _len;

      if (isFile == null) {
        isFile = true;
      }
      if (ignoreSrc == null) {
        ignoreSrc = false;
      }
      success = ignoreSrc ? true : this.src.mv(file1, file2, isFile);
      if (isFile) {
        f = this.index.get_file(file1);
        if (f) {
          f.path = file2;
          this.index.rm(file1);
          this.index.add_file(file2, f);
        }
      } else {
        ls = this.index.ls(file1);
        for (_i = 0, _len = ls.length; _i < _len; _i++) {
          f_name = ls[_i];
          this.mv(f_name, path2 + f_name.substr(path1.length), true, true);
        }
        this.index.rm(file1);
      }
      return success;
    };

    return CacheSource;

  })(FileSource);

  FSState = (function() {
    function FSState() {
      var f, mainSource;

      this.home = '/home/doppio';
      this.pwd = this.home;
      mainSource = new CompositedFileSource('/', [new LocalStorageSource('/'), new WebserverSource('/home/doppio', '/browser/listings.json')]);
      this.files = new CacheSource('/', mainSource);
      f = new DoppioFile('/home/doppio/Hello.txt', "Welcome to Doppio!");
      f.mod = true;
      this.files.store('/home/doppio/Hello.txt', f);
    }

    FSState.prototype.resolve = function(path) {
      var absolute, c, components, i, idx, processed, pwdCmp, _i, _j, _k, _len, _len1, _ref;

      components = path.split('/');
      absolute = path[0] === '/';
      for (idx = _i = 0, _len = components.length; _i < _len; idx = ++_i) {
        c = components[idx];
        if (c === '.') {
          components[idx] = '';
        }
        if (c === '~') {
          components[idx] = this.home;
        }
      }
      if (!absolute) {
        _ref = this.pwd.split('/');
        for (_j = _ref.length - 1; _j >= 0; _j += -1) {
          pwdCmp = _ref[_j];
          components.unshift(pwdCmp);
        }
      }
      for (idx = _k = 0, _len1 = components.length; _k < _len1; idx = ++_k) {
        c = components[idx];
        if (c === '..') {
          processed = false;
          i = idx - 1;
          while (!processed) {
            if (i < 0) {
              processed = true;
            }
            if (components[i] !== '') {
              components[i] = '';
              components[idx] = '';
              processed = true;
            }
            i--;
          }
        }
      }
      path = ((function() {
        var _l, _len2, _results;

        _results = [];
        for (idx = _l = 0, _len2 = components.length; _l < _len2; idx = ++_l) {
          c = components[idx];
          if (c !== '') {
            _results.push(c);
          }
        }
        return _results;
      })()).join('/');
      if (path[0] !== '/') {
        path = '/' + path;
      }
      return path;
    };

    FSState.prototype.open = function(path, mode) {
      var f;

      if (mode == null) {
        mode = 'r';
      }
      path = this.resolve(path);
      if (this.is_directory(path)) {
        return null;
      }
      if (mode === 'w') {
        f = new DoppioFile(path);
        f.mod = true;
        return f;
      }
      return this.files.fetch(path);
    };

    FSState.prototype.close = function(file) {
      this.files.store(file.path, file);
      file.mod = false;
    };

    FSState.prototype.list = function(path) {
      return this.files.ls(this.resolve(path));
    };

    FSState.prototype.is_file = function(path) {
      return this.files.fetch(this.resolve(path)) != null;
    };

    FSState.prototype.is_directory = function(path) {
      return this.list(path) != null;
    };

    FSState.prototype.rm = function(path, isDir) {
      if (isDir == null) {
        isDir = false;
      }
      path = this.resolve(path);
      if (this.is_directory(path) !== isDir) {
        return false;
      } else {
        return this.files.rm(path);
      }
    };

    FSState.prototype.chdir = function(dir) {
      dir = this.resolve(dir);
      if (this.is_directory(dir)) {
        this.pwd = dir;
        return dir;
      } else {
        return null;
      }
    };

    FSState.prototype.mkdir = function(dir) {
      dir = this.resolve(dir);
      if (this.is_directory(dir || this.is_file(dir))) {
        return false;
      }
      return this.files.mkdir(dir);
    };

    FSState.prototype.mv = function(file1, file2) {
      file1 = this.resolve(file1);
      file2 = this.resolve(file2);
      return this.files.mv(file1, file2);
    };

    return FSState;

  })();

  fs_state = new FSState();

  Stat = (function() {
    Stat.fromPath = function(path) {
      var file, stat;

      if (path === '') {
        return null;
      }
      if (fs_state.is_directory(path)) {
        stat = new Stat;
        stat.size = 1;
        stat.mtime = (new Date).getTime();
        stat.is_file = false;
        stat.is_directory = true;
        stat.mode = 0x1a4;
        return stat;
      } else {
        file = fs_state.open(path, 'r');
        if (file == null) {
          return null;
        }
        return new Stat(file);
      }
    };

    function Stat(file) {
      this.file = file;
      if (this.file != null) {
        this.size = this.file.data.length;
        this.mtime = this.file.mtime;
        this.is_file = true;
        this.is_directory = false;
        this.mode = this.file.mode;
      }
    }

    Stat.prototype.isFile = function() {
      return this.is_file;
    };

    Stat.prototype.isDirectory = function() {
      return this.is_directory;
    };

    return Stat;

  })();

  win.Buffer = (function() {
    function Buffer(obj) {
      if (obj instanceof Array) {
        this.array = obj;
      } else {
        this.array = new Array(obj);
      }
    }

    Buffer.prototype.readUInt8 = function(i) {
      return this.array[i] & 0xFF;
    };

    Buffer.prototype.readInt8 = function(i) {
      return this.array[i];
    };

    return Buffer;

  })();

  root.fs = {
    statSync: function(path) {
      return Stat.fromPath(path);
    },
    stat: function(path, cb) {
      var stat;

      stat = root.fs.statSync(path);
      if (stat != null) {
        return cb(null, stat);
      } else {
        return cb(new Error("Invalid file: " + path, null));
      }
    },
    fstatSync: function(fp) {
      return new Stat(fp);
    },
    openSync: function(path, mode) {
      var err, f;

      if (__indexOf.call(mode, 'w') >= 0) {
        mode = 'w';
      } else if (__indexOf.call(mode, 'a') >= 0) {
        mode = 'a';
      } else {
        mode = 'r';
      }
      f = fs_state.open(path, mode);
      if (f == null) {
        err = new Error;
        err.code = 'ENOENT';
        throw err;
      }
      return f;
    },
    open: function(path, mode, cb) {
      var e, f;

      if (cb == null) {
        cb = mode;
        mode = 'r';
      }
      try {
        f = root.fs.openSync(path, mode);
        return cb(null, f);
      } catch (_error) {
        e = _error;
        return cb(e);
      }
    },
    readSync: function(fd, buf, offset, length, pos) {
      var d, data, i, _i, _len;

      data = fd.read(length, pos);
      for (i = _i = 0, _len = data.length; _i < _len; i = ++_i) {
        d = data[i];
        buf.array[offset + i] = data.charCodeAt(i) & 0xFF;
      }
      return data.length;
    },
    readFileSync: function(path) {
      var f;

      f = fs_state.open(path, 'r');
      if (f == null) {
        throw "File does not exist.";
      }
      return f.data;
    },
    readFile: function(path, cb) {
      var data, e;

      try {
        data = root.fs.readFileSync(path);
        return cb(null, data);
      } catch (_error) {
        e = _error;
        return cb(e);
      }
    },
    writeFileSync: function(path, data, encoding, temp) {
      var f;

      f = fs_state.open(path, 'w');
      f.temp = temp === true;
      f.write(data);
      return fs_state.close(f);
    },
    writeFile: function(path, data, cb) {
      return cb(null, root.fs.writeFileSync(path, data));
    },
    writeSync: function(fd, buffer, offset, len, pos) {
      var i, str;

      if (buffer.readUInt8 != null) {
        str = ((function() {
          var _i, _ref, _results;

          _results = [];
          for (i = _i = offset, _ref = offset + len; _i < _ref; i = _i += 1) {
            _results.push(String.fromCharCode(buffer.readUInt8(i)));
          }
          return _results;
        })()).join('');
      } else {
        str = '' + buffer;
        pos = offset;
      }
      return fd.write(str, pos);
    },
    closeSync: function(fd) {
      return fs_state.close(fd);
    },
    close: function(fd, cb) {
      root.fs.closeSync(fd);
      return cb();
    },
    readdirSync: function(path) {
      var dir_contents;

      dir_contents = fs_state.list(path);
      if (!((dir_contents != null) && path !== '')) {
        throw "Could not read directory '" + path + "'";
      }
      return dir_contents;
    },
    readdir: function(path, cb) {
      var e, files;

      try {
        files = root.fs.readdirSync(path);
        return cb(null, files);
      } catch (_error) {
        e = _error;
        return cb(e);
      }
    },
    unlinkSync: function(path) {
      if (!fs_state.rm(path)) {
        throw "Could not unlink '" + path + "'";
      }
    },
    unlink: function(path, cb) {
      var e;

      try {
        root.fs.unlinkSync(path);
        return cb();
      } catch (_error) {
        e = _error;
        return cb(e);
      }
    },
    rmdirSync: function(path) {
      if (!fs_state.rm(path, true)) {
        throw "Could not delete '" + path + "'";
      }
    },
    rmdir: function(path, cb) {
      var e;

      try {
        root.fs.rmdirSync(path);
        return cb();
      } catch (_error) {
        e = _error;
        return cb(e);
      }
    },
    existsSync: function(path) {
      return path !== '' && (fs_state.is_file(path) || fs_state.is_directory(path));
    },
    exists: function(path, cb) {
      return cb(null, root.fs.existsSync(path));
    },
    mkdirSync: function(path) {
      if (!fs_state.mkdir(path)) {
        throw "Could not make directory " + path;
      }
    },
    mkdir: function(path, cb) {
      var e;

      try {
        root.fs.mkdirSync(path);
        return cb();
      } catch (_error) {
        e = _error;
        return cb(e);
      }
    },
    renameSync: function(path1, path2) {
      if (!fs_state.mv(path1, path2)) {
        throw "Could not rename " + path1 + " to " + path2;
      }
    },
    rename: function(path1, path2, cb) {
      var e;

      try {
        root.fs.renameSync(path1, path2);
        return cb();
      } catch (_error) {
        e = _error;
        return cb(e);
      }
    },
    chmodSync: function(path, access) {
      var f;

      if (!fs_state.is_file(path)) {
        throw "File " + path1 + " does not exist.";
      }
      f = fs_state.open(path, 'r');
      f.mod = true;
      f.mode = access;
      fs_state.close(f);
      return true;
    },
    chmod: function(path, access, cb) {
      var e, rv;

      try {
        rv = root.fs.chmodSync(path, access);
        return cb(null, rv);
      } catch (_error) {
        e = _error;
        return cb(e);
      }
    },
    utimesSync: function(path, atime, mtime) {},
    utimes: function(path, atime, mtime, cb) {
      return cb();
    }
  };

  root.path = {
    normalize: function(path) {
      return fs_state.resolve(path);
    },
    resolve: function() {
      var parts;

      parts = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      return fs_state.resolve(parts.join('/'));
    },
    basename: function(path, ext) {
      var base;

      base = path.replace(/^.*[\/\\]/, '');
      if (((ext != null ? ext.length : void 0) != null) && base.slice(base.length - ext.length) === ext) {
        base = base.slice(0, base.length - ext.length);
      }
      return base;
    },
    extname: function(path) {
      return path.replace(/^.*(\..*)/, '$1');
    }
  };

  root.process = {
    cwd: function() {
      return fs_state.pwd;
    },
    chdir: function(dir) {
      var absdir;

      absdir = fs_state.chdir(dir);
      if (absdir == null) {
        throw "Invalid directory";
      }
      return absdir;
    }
  };

  if (window.setImmediate == null) {
    window.setImmediate = setZeroTimeout;
  }

}).call(this);
